"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)

openmm_run.py

This program is OpenMM running scripts written in python.

Correspondance: jul316@lehigh.edu or wonpil@lehigh.edu
Last update: June 18, 2021
"""

from __future__ import print_function
import argparse
import sys
import os
import numpy as np
from openmmtools import *
from openmmtools.multistate import *

from omm_readinputs import *
from omm_readparams import *
from omm_vfswitch import *
from omm_barostat import *
from omm_restraints import *
from omm_rewrap import *

from simtk.unit import *
from simtk.openmm import *
from simtk.openmm.app import *

parser = argparse.ArgumentParser()
parser.add_argument('--platform', nargs=1, help='OpenMM platform (default: CUDA or OpenCL)')
parser.add_argument('--round', type=int, help='Number of iterations (default: 100)', default=100)
parser.add_argument('--steps', type=int, help='Number of steps per iteration (default: 5000)', default=5000)
parser.add_argument('-i', dest='inpfile', help='Input parameter file', required=True)
parser.add_argument('-g', dest='grofile', help='Input Gromacs gro file', required=True)
parser.add_argument('-t', dest='topfile', help='Input Gromacs top file', required=True)
parser.add_argument('-irst', metavar='RSTFILE', dest='irst', help='Input restart file (optional)')
parser.add_argument('-ichk', metavar='CHKFILE', dest='ichk', help='Input checkpoint file (optional)')
parser.add_argument('-opdb', metavar='PDBFILE', dest='opdb', help='Output PDB file (optional)')
parser.add_argument('-orst', metavar='RSTFILE', dest='orst', help='Output restart file (optional)')
parser.add_argument('-ochk', metavar='CHKFILE', dest='ochk', help='Output checkpoint file (optional)')
parser.add_argument('-odcd', metavar='DCDFILE', dest='odcd', help='Output trajectory file (optional)')
parser.add_argument('-rewrap', dest='rewrap', help='Re-wrap the coordinates in a molecular basis (optional)', action='store_true', default=False)
args = parser.parse_args()



# Load parameters
print("Loading parameters")
inputs = read_inputs(args.inpfile)
#params = read_params(args.toppar)

psf = read_top(args.topfile, args.grofile)
top = psf
crd = read_crd(args.grofile)



# Build system
nboptions = dict(nonbondedMethod=inputs.coulomb,
                 nonbondedCutoff=inputs.r_off*nanometers,
                 constraints=inputs.cons,
                 ewaldErrorTolerance=inputs.ewald_Tol)
if inputs.vdw == 'Switch': nboptions['switchDistance'] = inputs.r_on*nanometers
if inputs.vdw == 'LJPME':  nboptions['nonbondedMethod'] = LJPME

system = psf.createSystem(**nboptions)
#if inputs.vdw == 'Force-switch': system = vfswitch(system, psf, inputs)
#
#if inputs.lj_lrc == 'yes':
#    for force in system.getForces():
#        if isinstance(force, NonbondedForce): force.setUseDispersionCorrection(True)
#        if isinstance(force, CustomNonbondedForce) and force.getNumTabulatedFunctions() != 1:
#            force.setUseLongRangeCorrection(True)
#
#if inputs.e14scale != 1.0:
#    for force in system.getForces():
#        if isinstance(force, NonbondedForce): nonbonded = force; break
#    for i in range(nonbonded.getNumExceptions()):
#        atom1, atom2, chg, sig, eps = nonbonded.getExceptionParameters(i)
#        nonbonded.setExceptionParameters(i, atom1, atom2, chg*inputs.e14scale, sig, eps)
#
if inputs.pcouple == 'yes':      system = barostat(system, inputs)
if inputs.rest == 'yes':         system = restraints(system, crd, inputs)
integrator = LangevinIntegrator(inputs.temp*kelvin, inputs.fric_coeff/picosecond, inputs.dt*picoseconds)


# Set platform
DEFAULT_PLATFORMS = 'CUDA', 'OpenCL', 'CPU'
enabled_platforms = [Platform.getPlatform(i).getName() for i in range(Platform.getNumPlatforms())]
if args.platform:
    if not args.platform[0] in enabled_platforms:
        print("Unable to find OpenMM platform '{}'; exiting".format(args.platform[0]), file=sys.stderr)
        sys.exit(1)

    platform = Platform.getPlatformByName(args.platform[0])
else:
    for platform in DEFAULT_PLATFORMS:
        if platform in enabled_platforms:
            platform = Platform.getPlatformByName(platform)
            break
    if isinstance(platform, str):
        print("Unable to find any OpenMM platform; exiting".format(args.platform[0]), file=sys.stderr)
        sys.exit(1)

print("Using platform:", platform.getName())
prop = dict(CudaPrecision='single') if platform.getName() == 'CUDA' else dict()

n_replicas = 3
rsts = []
if args.irst:
    for i in range(0, n_replicas):
        with open(args.irst+'_'+str(i)+'.rst', 'r') as f:
            rsts.append(XmlSerializer.deserialize(f.read()))

T_list = [300., 310, 320.]*unit.kelvin
thermodynamic_states = [states.ThermodynamicState(system=system, temperature=T) for T in T_list]
reference_state = states.ThermodynamicState(system=system, temperature=T_list[0])
move = mcmc.LangevinDynamicsMove(
    timestep=inputs.dt*unit.picosecond,
    collision_rate=1.0/unit.picosecond,
    n_steps=args.steps,
    reassign_velocities=False,
)
simulation = ParallelTemperingSampler(mcmc_moves=move)
storage_path = args.odcd+'.nc'
reporter = MultiStateReporter(storage_path, checkpoint_interval=1000)
simulation.create(reference_state, sampler_states=states.SamplerState(positions=rsts[0].getPositions(), velocities=rsts[0].getVelocities(), 
        box_vectors=rsts[0].getPeriodicBoxVectors()), storage=reporter, temperatures=T_list, n_temperatures=n_replicas)
for i in range(1, n_replicas):
    simulation.sampler_states[i].positions = rsts[i].getPositions()
    simulation.sampler_states[i].velocities = rsts[i].getVelocities()
    simulation.sampler_states[i].box_vectors = rsts[i].getPeriodicBoxVectors()



# Production
if inputs.nstep > 0:
    simulation.run(0)
    print(reporter.read_replica_thermodynamic_states(0))
    for i in range(0, args.round):
        simulation.extend(1)
        print(reporter.read_replica_thermodynamic_states(i))
        if i % int(inputs.nstep/inputs.nstdcd) == 0:
            for j in range(0, n_replicas):
                if i == 0:
                    filename = open(args.odcd+'_rep'+str(j)+'.dcd', 'wb')
                else:
                    filename = open(args.odcd+'_rep'+str(j)+'.dcd', 'r+b')
                crd = simulation.sampler_states[j].positions
                a,b,c = simulation.sampler_states[j].box_vectors
                box = Vec3(a[0].value_in_unit(unit.nanometer), b[1].value_in_unit(unit.nanometer), c[2].value_in_unit(unit.nanometer))*unit.nanometer
                DCDFile(filename, top.topology, move.timestep, 0, 1).writeModel(crd, box)

# write restart file
if not (args.orst or args.ochk): args.orst = 'output.rst'
if args.orst:
    for i in range(0, n_replicas):
        
        _context = thermodynamic_states[i].create_context(openmm.VerletIntegrator(2.0*unit.femtosecond))
        simulation.sampler_states[i].apply_to_context(_context)
        
        with open(args.orst+'_'+str(i)+'.rst', 'w') as f:
            f.write(openmm.XmlSerializer.serialize(_context.getState(getPositions=True, getVelocities=True)))
    

if args.opdb:
    for i in range(0, n_replicas):
        crd = simulation.sampler_states[i].positions
        PDBFile.writeFile(top.topology, crd, open(args.opdb+'_rep'+str(i)+'.pdb', 'w'))

